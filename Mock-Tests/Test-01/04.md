### C언어 메모리 출력 문제 해설

---

### 📘 문제 설명

다음은 C언어 코드이다. 출력 결과를 쓰시오.

```c
#include <stdio.h>

int main() {
    int a[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int *p = a[1] + 2;
    int *q = &a[0][1];

    printf("%d ", p[1]);
    printf("%d", q[2]);

    return 0;
}
```

### 🔍 문제 분석
✅ 배열 a의 메모리 구성

```
a[0][0] = 1   a[0][1] = 2   a[0][2] = 3  
a[1][0] = 4   a[1][1] = 5   a[1][2] = 6  
a[2][0] = 7   a[2][1] = 8   a[2][2] = 9

이차원 배열은 메모리상에 연속된 1차원 배열처럼 저장됩니다:

1, 2, 3, 4, 5, 6, 7, 8, 9

```

### 🧠 포인터 분석

```
int *p = a[1] + 2;
a[1]은 &a[1][0] (두 번째 행 시작점)

a[1] + 2 → &a[1][2] → 값: 6

p = &a[1][2], *p = 6

p[1] = *(p + 1) = a[2][0] = 7

int *q = &a[0][1];
q = &a[0][1] → 값: 2

q[2] = *(q + 2) = a[1][0] = 4
```

### 🔎 풀이 과정

```
printf("%d ", p[1]); // p = &a[1][2], p[1] = a[2][0] = 7
printf("%d", q[2]);  // q = &a[0][1], q[2] = a[1][0] = 4
```

### ✅ 최종 출력 결과

```
7 4
```

### 🧾 추가 설명 (메모리 순서 기반 접근)

- C언어 다차원 배열은 실제로 1차원 배열처럼 연속 메모리로 저장됨
- 따라서 포인터 연산 (+, [])을 사용해 다음 행의 요소에도 접근 가능
- p[1]은 a[1][2] 다음 요소 → 즉 a[2][0]을 의미함
